#pragma rtGlobals=1		// Use modern global access method.//LoadRecord64CW//Loads a data file recorded with Record64CW (continuous wave)//Supports two formats://File type 1: Samples from different channels are interleaved//File type 2: Data is written in blocks of <windowsize>.//			    Example - if <windowsize> is 2 seconds, data is written//			    ch0 (0-2 s),ch 1(0-2 s), ... , ch n(0-2 s), ch0 (2-4 s),...//			    This format is used for faster loading time during analysis.menu "Load Data" 	"LoadRecord64CW" 	"LoadFile" 	"LoadAllFiles"end//Loads all file in a foldermacro loadallfiles()	silent 1;pauseupdate	newpath  /q/o mp 	PathInfo mp	string filelist=indexedfile (mp,-1,"BINA")	variable i,numitems=itemsinlist (filelist,";")	do		loadfile (s_path+stringfromlist (i,filelist),"N")		i+=1	while (i<numitems)end//Loads one file//fname is a full path namemacro loadfile(fname,dflag)	string fname,dflag	prompt dflag,"Get filename from dialog?",popup,"Y;N"	prompt fname,"Cell name"	silent 1;pauseupdate	LoadRecord64CW (2,-1,1000,0,fname,dflag)end//LoadRecord64CW: Main routine to load record64CW data//repeatlength:Length of data to load in at a time - constrained by memory//totlength:Total length of data to load//outsrate: Final sample rate of data, rate of recording is read from file//rootwavename:name for recording//dialogflag:If "Y", dialog is opened to find file, if "n", rootwavename is//			assumed to be a Full path to the file.//Three channels are designated as special://Ch0, assumed to be a voltage recording. Result is placed in <rootwavename>+"_V"//Ch1, assumed to be a current recording.  Result is placed in <rootwavename>+"_I"//Ch2, assumed to be an event pulse recording. Pulse times and widths are detected, and//placed in <rootwavename>+"_E" and <rootwavename>+"_W", respectively.Macro LoadRecord64CW (repeatlength,totlength, outsrate,loadchannum,rootwavename,dialogflag)	string rootwavename,dialogflag="Y"	variable startoffset=0,repeatlength=2,outsrate=10000,loadchannum=0,totlength=10,ch	//prompt startoffset,"Start time"	prompt repeatlength,"Segment length"	prompt totlength,"Total length"	prompt loadchannum,"Load channel"	prompt outsrate,"Output sample rate"	prompt rootwavename,"Enter prefix for variable name"	prompt dialogflag,"Get filename from dialog?",popup,"Y;N"	string bchanname	//Get file name	variable filenum	if (stringmatch(dialogflag,"Y"))		string filepathname		Open /D/R/M="Select Path:" /T="????" filenum					//generates path to file		filepathname=s_filename		print filepathname	else		string filepathname=rootwavename		rootwavename=filefrompath (rootwavename,1)	endif	//Make celllist if it doesn't exist	if (!waveexists ($"celllist"))		make /t/n=1 celllist	endif		//If cell already exists, check with user to continue	if (intextwave("celllist",rootwavename))		print "CELL "+rootwavename+" ALREADY EXISTS"		checkcellname()	else		insertpoints numpnts(celllist),1,celllist		celllist (numpnts(celllist))=rootwavename	endif		//Get file size	Open /R/T="BINA" filenum as filepathname	fstatus filenum	variable filesize=v_logeof	close filenum	//Read file header	Silent 1; PauseUpdate	variable dataOffset, filetype,fileversion,numSamples, numChannels, scanRate, vScale, vOffset,skip	Make/O/N=64/B activeChannel		GBLoadWave/Q/O/V/N=wave/T={32,32}/W=1/U=1 (filepathname)	dataOffset = wave0[0]	skip=4	GBLoadWave/Q/O/V/N=wave/T={16,16}/S=(skip)/W=1/U=1 (filepathname)	filetype = wave0[0]	skip+=2	GBLoadWave/Q/O/V/N=wave/T={16,16}/S=(skip)/W=1/U=1 (filepathname)	fileversion = wave0[0]	skip+=2	GBLoadWave/Q/O/V/N=wave/T={96,96}/S=(skip)/W=1/U=1 (filepathname)	numSamples = wave0[0]	skip+=4	GBLoadWave/Q/O/V/N=wave/T={32,32}/S=(skip)/W=1/U=1 (filepathname)	numChannels = wave0[0]	skip+=4	GBLoadWave/Q/O/V/N=wave/T={16,16}/S=(skip)/W=1/U=(numchannels) (filepathname)	duplicate /o wave0,chanlist	skip+=numchannels*2	GBLoadWave/Q/O/V/N=wave/T={2,2}/S=(skip)/W=1/U=1 (filepathname)	scanRate = wave0[0]	KillWaves /Z wave0	if (filetype==2) //Block format		variable windowsize		skip+=4		GBLoadWave/Q/O/V/N=wave/T={32,32}/S=(skip)/W=1/U=1 (filepathname)		windowsize= wave0[0]		KillWaves /Z wave0		repeatlength=windowsize/scanRate	endif	//End reading header	//Calculate end of data	variable numrepeats	if (totlength<1)		numrepeats = (filesize-dataOffset)/(numChannels*scanrate*repeatlength*2)	else		numrepeats=min(totlength/repeatlength, (filesize-dataOffset)/(numChannels*scanrate*repeatlength*2))	endif	totlength=repeatlength*numrepeats	//Store filename	string cellfname=rootwavename+"_f"	make /o/t/n=1 $cellfname=filefrompath(filepathname,2)		//Find channels	variable vchannum,ichannum,epchannum	findvalue /v=(loadchannum) chanlist;vchannum=v_value	findvalue /v=1 chanlist;ichannum=v_value	findvalue /v=2 chanlist;epchannum=v_value	variable eventoffset	string vwavename,iwavename,epwavename,ewwavename,bwavename,vchanname,ichanname,epchanname		if (vchannum>=0)			vwavename=rootwavename+"_V"			make /o/N=(totlength*outsrate) $vwavename			setscale /p x 0,(1/outsrate),$vwavename			if (filetype==1)				vchanname="bwave"+num2str(vchannum)			else if (filetype==2)				vchanname="bwave0"			endif	endif	if (ichannum>=0)			iwavename=rootwavename+"_I"			make /o/N=(totlength*outsrate) $iwavename			setscale /p x 0,(1/outsrate),$iwavename			if (filetype==1)				ichanname="bwave"+num2str(ichannum)			else if (filetype==2)				ichanname="bwave0"			endif	endif	if (epchannum>=0)			epwavename=rootwavename+"_E"			ewwavename=rootwavename+"_W"			if (filetype==1)				 epchanname="bwave"+num2str(epchannum)			else if (filetype==2)				 epchanname="bwave0"			endif	endif				variable filerepeatlength,channeloffset	filerepeatlength=repeatlength*scanrate*numchannels*2 //  2 is for 2 bytes	variable RepNo=0,firstpulse	do		Silent 1; PauseUpdate		killwaves /z bwave0,bwave1		if (filetype ==1)			GBLoadWave/q/O/V/N=bwave/T={16,16}/S=(dataOffset+(RepNo)*filerepeatlength)/W=(numchannels)/U=(repeatlength*scanrate) (filepathname)		endif		//Event pulse channel		if (epchannum>=0)			if (filetype ==2)				GBLoadWave/q/O/V/N=bwave/T={16,16}/S=(dataOffset+(RepNo)*filerepeatlength+windowsize*epchannum*2)/W=1/U=(repeatlength*scanrate) (filepathname)			endif			Setscale/P x,0,(1/scanrate),$epchanname	 				findpulses($epchanname,500)			if  (Repno==0)				duplicate /o ptime,$epwavename				duplicate /o pwidth,$ewwavename			else				if (numpnts (ptime)>0)					ptime+=repno*repeatlength					appendwave (epwavename,"ptime")					appendwave (ewwavename,"pwidth")				endif			endif		endif		// Voltage recording channel		if (vchannum>=0)			if (filetype ==2)				GBLoadWave/q/O/V/N=bwave/T={16,16}/S=(dataOffset+(RepNo)*filerepeatlength+windowsize*vchannum*2)/W=1/U=(repeatlength*scanrate) (filepathname)			endif				Setscale/P x,0,(1/scanrate),$vchanname			if (outsrate<scanrate)				reducesamplinginplace (vchanname,(1/outsrate))			endif			$vwavename[repeatlength*outsrate*RepNo,repeatlength*outsrate*(RepNo+1)-1]=$vchanname[p-repeatlength*outsrate*RepNo]		endif		//Current recording channel		if(ichannum>=0)			if (filetype ==2)				GBLoadWave/q/O/V/N=bwave/T={16,16}/S=(dataOffset+(RepNo)*filerepeatlength+windowsize*ichannum*2)/W=1/U=(repeatlength*scanrate) (filepathname)			endif			Setscale/P x,0,(1/scanrate),$ichanname			if (outsrate<scanrate)				reducesamplinginplace (ichanname,(1/outsrate))			endif			$iwavename[repeatlength*outsrate*RepNo,repeatlength*outsrate*(RepNo+1)-1]=$ichanname[p-repeatlength*outsrate*RepNo]		endif		RepNo+=1	while (RepNo<numrepeats)	if (vchannum>=0)		$vwavename/=20 //SCALE FOR GAIN x100	endif	Silent 1; PauseUpdate	string oldName, newName	display $vwavename	//killwaves /z bwave0,activeChannelend	//Findpulses: Finds pulses above a certain threshold and //creates waves with their times and widthsFunction findpulses(win,thr)	wave win	variable thr	//Duplicate win into single precision	//wave nwin	make /o/n=(numpnts(win)) nwin	setscale /p x,leftx(win),deltax(win),nwin	nwin=win	make/o/n=1 plev	findlevels /q/d=plev nwin,thr	make /o/n=(v_levelsfound/2) ptime,pwidth	if (numpnts (plev)>0)		plev=x2pnt(nwin,plev)		ptime=0		pwidth=0		variable i=0,pnum=0		do			if ((nwin[plev[i]-1]<thr)%&(nwin[plev[i+1]+1]<thr))				ptime[pnum]=plev[i]				pwidth[pnum]=plev[i+1]-plev[i]				pnum+=1			endif			i+=1		while (i<numpnts(plev))		ptime*=deltax(win)		pwidth*=deltax(win)	endif	killwaves /z plev,nwinend//**************REDUCESAMPLINGINPLACE*********************//Assumes Nwavein is in dimensions of seconds. Creates a new wave Nwavein_filtered//that has an deltax value of binSize seconds (binSize > original deltax) and values averaged over //(binSize deltax/original deltax) original bins. If mod(binSize deltax/original deltax)!=0//only int(binSize deltax/original deltax) points are used in averaging, resulting in significant error// if int(binSize deltax/original deltax) is small.Function ReduceSamplingInPlace(Nwavein, binSize)string Nwaveinvariable binSizewave wavein=$NwaveinRedimension/S waveinvariable originalbin, reduction,  startbinoriginalbin=deltax(wavein)if (originalbin>=binSize)	print "input wave is undersampled"	return 0endifstring Nwaveoutsprintf Nwaveout, "%s_filtered", Nwaveinmake/o/n=(floor((numpnts(wavein)*originalbin)/binSize)) $Nwaveoutwave waveout=$Nwaveoutstartbin=leftx($nwavein)+binSize/2SetScale/P x, startbin,binSize, waveoutwaveout=mean(wavein, x-binSize/2, x+binSize/2)duplicate /o waveout,$Nwaveinkillwaves waveoutend//**************FILEFROMPATH***********//Accepts path name and returns the last <level> elements//The convention is that the folder is the date of the experiment//and the file name is the recording numberFunction /S Filefrompath (Npathname,level)string Npathnamevariable levelstring filenamevariable len=itemsinlist(Npathname,":"),lvl=1filename=""do	if (lvl==1)		filename=stringfromlist(len-1,Npathname,":")		else		filename=stringfromlist(len-lvl,Npathname,":")+":"+filename	endif	lvl+=1while (lvl<=level)return filenameend	//Creates a new cell in the text wave celllistmacro newcell(sname)	string sname	if (stringmatch(wavelist("celllist",";",""),"")==1)		make /t/n=1 celllist		listcells()		celllist[1]=sname	endif	if (!intextwave("celllist",sname))	 	insertpoints numpnts(celllist),1,celllist	 	celllist (numpnts(celllist))=sname	 endifend//Prompt to allow user to stop execution if a cell will be overwrittenmacro checkcellname (flag)	string flag	prompt flag,"***CELL ALREADY EXISTS*** (See command window). To REPLACE CELL, hit 'Continue':"end//Finds a string in a text wave and returns the point numberfunction intextwave(swavein,stringin)	string swavein,stringin	wave /t wtwave=$swavein	variable i=0,result=0	string twstring	do		if (stringmatch(wtwave[i],stringin))			result=1		endif			i+=1	while (i<numpnts(wtwave))	return resultend//Converts a string list to a text wavefunction listtotextwave (sname,twname)	string sname,twname	variable i=0,numitems=itemsinlist(sname)	make /t/o/n=(numitems) $twname	wave /t wtwave=$twname	do		wtwave[i]=StringFromList(i,sname)		i+=1	while (i<numitems)	end//Converts text wave to a string listfunction /s textwavetolist (twname) 	string twname	string list=""	wave /t wtwave=$twname	variable i=0,numitems=numpnts(wtwave)	do		list+=wtwave[i]+";"		i+=1	while (i<numitems)		return listend	//Appends wave2 to wave1function appendwave (swin1,swin2)	string swin1,swin2	wave win1=$swin1,win2=$swin2	duplicate /o win2 wtemp	insertpoints numpnts(win1),numpnts(wtemp),win1	win1[numpnts(win1)-numpnts(wtemp),numpnts(win1)]=wtemp[p-numpnts(win1)+numpnts(wtemp)]	killwaves /z wtempend